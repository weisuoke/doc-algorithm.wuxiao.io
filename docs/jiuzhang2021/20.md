---
nav:
    title: 九章-算法班2021
    order: 10
title: 最难的算法 --- 动态规划
order: 21
---

# 最难的算法 --- 动态规划

## **动态规划的核心思想**

由大化小

动态规划的算法思想:大规模问题的依赖于小规模问题的计算结果

## 动态规划的两种实现方式

- 递归(Recursion)方式 => 记忆化搜索 (上节课)
- 循环(Iteration)方式 (本节课)

### 记忆化搜索时间复杂度

= 动态规划的时间复杂度

= O(状态总数 * 计算每个状态的时间耗费)

## **动态规划为什么难?**

- 动态规划是一种算法范式(算法思想，Algorithmic Paradigm，而不是很具体的算法(Algorithm) 
- 每个子类型都是一个新的算法
- 学习周期很长，一月入门，两月上手

## **我可以放弃么?**

- 北美求职者:如果你不想去Google等某些炙手可热的公司，可以 
- 国内求职者:如果你不去大厂，可以(国内大厂面试题超过 50% 的题都是动态规划)

## 三种适用动规的场景

**求可行性**

- dp[] 的值是 true / false
- dp[大问题] = dp[小问题1] or dp[小问题2] or ...
- 代码通常用 for 小问题 if dp[小问题] == true then break 的形式实现

**求方案数**

- dp[]的值的类型是方案数(整数)
- dp[大问题]=∑ (dp[小问题 1] ，dp[小问题2], ...)
- ∑  = sum

**求最值**

- dp[]的值的类型是最优值的类型
- dp[大问题] = max{dp[小问题1], dp[小问题2], ...}
- dp[大问题] = min{dp[小问题1], dp[小问题2], ...}

## 动态规划的解题步骤

1. 判断是否能够使用动态规划算法
2. 判断动态规划的题型
3. 使用动规四要素进行解题

### 动态规划题型分类

![image-20210927134204772](https://wsk-mweb.oss-cn-hangzhou.aliyuncs.com/ipic/2021-09-27-054207.png)

### 动规四要素

![image-20210927134500181](https://wsk-mweb.oss-cn-hangzhou.aliyuncs.com/ipic/2021-09-27-054502.png)

## 动态规划的空间优化技巧

### 滚动数组 Rolling Array

- 如果状态依赖关系只在相邻的几层之间
- 则可以使用滚动数组进行优化
- 滚动数组可以让空间复杂度降维

#### 题目

- 109 **Triangle** **数字三角形**
- 630 **Knight Shortest Path II**
- 76 **Longest Increasing Subsequence** **最长上升子序列**
- 398 **Longest Continuous Increasing Subsequence II** **最长上升连续子序列** **II**
- 630 **Largest Divisible Subset** **最大整除子集**

#### **滚动数组小结**

- 滚动数组滚动的是第一重循环的变量，而不是第二重甚至第三重

- 外层循环决定了是逐行还是逐列。如果外层循环是列，就是逐列;如果外层循环是行，就是逐行。

- 滚动数组也只能滚一个维度，不能两个维度一起滚动

- 逐行(列)生成数据，就在行(列)上滚动

- 逐行滚动可能从左至右，或者从右至左;逐列滚动可能从上至下，或者从下至上
- 从非滚动变成滚动，只需要:在行(列)上滚动，行(列)index % 滚动行(列)数